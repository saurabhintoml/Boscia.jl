var documenterSearchIndex = {"docs":
[{"location":"#Boscia.jl","page":"Home","title":"Boscia.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A solver for Mixed-Integer Convex Optimization that uses Frank-Wolfe methods for convex relaxations and a branch-and-bound algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Boscia.jl solver uses a combination of a variant of the Frank-Wolfe algorithm and a branch-and-bound-like algorithm to solve mixed-integer convex optimization problems. These problems are of the form: min{x ∈ C, xI ∈ Z^n} f(x), where f is a differentiable convex function, C is a convex and compact set, and I is a set of indices for integer variables.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approach is particularly effective if we can solve the mixed-integer linear minimization problem over C efficiently and handle the integer constraints. The set C is specified using the MathOptInterface API or any domain-specific language (DSL) like Julia for Mathematical Programming (JuMP) that implements this API. The paper presenting the package with mathematical explanations and numerous examples can be found here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convex integer optimization with Frank-Wolfe methods: 2208.11010","category":"page"},{"location":"","page":"Home","title":"Home","text":"Boscia.jl uses FrankWolfe.jl for solving the convex subproblems, Bonobo.jl for managing the search tree, and oracles optimizing linear functions over the feasible set, for instance calling SCIP or any MOI-compatible solver to solve MIP subproblems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once you have installed Julia , From the Julia REPL, type ] to enter the Pkg REPL mode and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg > add Boscia\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"or alternatively you can do this ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add the Boscia stable release with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Boscia\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you don't have SCIP  , you can on go this link and add SCIP as instructed 'SCIP' If you want to use SCIP within Boscia and your OS is windows, you will have download SCIP separately, see SCIP.jl. Note that you do not necessarily have to download the binaries but can also use the installer provided by SCIP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For Window Users You need not to download whole SCIP binary instead you can follow Custom Installation mentioned on this page and download and link SCIP with your JULIA .","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example to get started. For more examples, see the examples folder in the package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nusing Boscia\nusing FrankWolfe\nusing Random\nusing SCIP\nusing LinearAlgebra\nimport MathOptInterface\nconst MOI = MathOptInterface\n\nn = 6\n\nconst diffw = 0.5 * ones(n)\no = SCIP.Optimizer()\n\nMOI.set(o, MOI.Silent(), true)\n\nx = MOI.add_variables(o, n)\n\nfor xi in x\n    MOI.add_constraint(o, xi, MOI.GreaterThan(0.0))\n    MOI.add_constraint(o, xi, MOI.LessThan(1.0))\n    MOI.add_constraint(o, xi, MOI.ZeroOne())\nend\n\nlmo = FrankWolfe.MathOptLMO(o)\n\nfunction f(x)\n    return sum(0.5*(x.-diffw).^2)\nend\n\nfunction grad!(storage, x)\n    @. storage = x-diffw\nend\n\nx, _, result = Boscia.solve(f, grad!, lmo, verbose = true)\n\nBoscia Algorithm.\n\nParameter settings.\n\t Tree traversal strategy: Move best bound\n\t Branching strategy: Most infeasible\n\t Absolute dual gap tolerance: 1.000000e-06\n\t Relative dual gap tolerance: 1.000000e-02\n\t Frank-Wolfe subproblem tolerance: 1.000000e-05\n\t Total number of varibales: 6\n\t Number of integer variables: 0\n\t Number of binary variables: 6\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n   Iteration       Open          Bound      Incumbent      Gap (abs)      Gap (rel)       Time (s)      Nodes/sec        FW (ms)       LMO (ms)  LMO (calls c)   FW (Its)   #ActiveSet  Discarded\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n*          1          2  -1.202020e-06   7.500000e-01   7.500012e-01            Inf   3.870000e-01   7.751938e+00            237              2              9         13            1          0\n         100         27   6.249998e-01   7.500000e-01   1.250002e-01   2.000004e-01   5.590000e-01   2.271914e+02              0              0            641          0            1          0\n         127          0   7.500000e-01   7.500000e-01   0.000000e+00   0.000000e+00   5.770000e-01   2.201040e+02              0              0            695          0            1          0\n---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nPostprocessing\n\nBlended Pairwise Conditional Gradient Algorithm.\nMEMORY_MODE: FrankWolfe.InplaceEmphasis() STEPSIZE: Adaptive EPSILON: 1.0e-7 MAXITERATION: 10000 TYPE: Float64\nGRADIENTTYPE: Nothing LAZY: true lazy_tolerance: 2.0\n[ Info: In memory_mode memory iterates are written back into x0!\n\n----------------------------------------------------------------------------------------------------------------\n  Type     Iteration         Primal           Dual       Dual Gap           Time         It/sec     #ActiveSet\n----------------------------------------------------------------------------------------------------------------\n  Last             0   7.500000e-01   7.500000e-01   0.000000e+00   1.086583e-03   0.000000e+00              1\n----------------------------------------------------------------------------------------------------------------\n    PP             0   7.500000e-01   7.500000e-01   0.000000e+00   1.927792e-03   0.000000e+00              1\n----------------------------------------------------------------------------------------------------------------\n\nSolution Statistics.\n\t Solution Status: Optimal (tree empty)\n\t Primal Objective: 0.75\n\t Dual Bound: 0.75\n\t Dual Gap (relative): 0.0\n\nSearch Statistics.\n\t Total number of nodes processed: 127\n\t Total number of lmo calls: 699\n\t Total time (s): 0.58\n\t LMO calls / sec: 1205.1724137931035\n\t Nodes / sec: 218.96551724137933\n\t LMO calls / node: 5.503937007874016","category":"page"}]
}
